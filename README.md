# myVue

* 只有被Vue代理的属性是响应的，在实例创建之后添加新的属性到实例上，新属性不会触发视图更新。
* 不要在实例属性或者回调函数中（如 vm.$watch('a', newVal => this.myMethod() ）使用`箭头函数`。因为箭头函数绑定父上下文，所以 `this` 不会像预想的一样是 Vue 实例，而是 `this.myMethod` 未被定义。
* 钩子 `created` `mounted` `updated` `destroyed`，钩子的 `this` 指向调用它的 Vue 实例。Vue没有“控制器”的概念。组件的自定义逻辑可以分布在这些钩子中。
* 计算属性依赖代理属性、计算属性依赖计算属性，代理属性发生改变时，依赖于代理属性的计算属性（以及依赖此计算属性的计算属性）也会更新。计算属性无法直接修改。
* 计算属性 和 Methods 可以得到相同的结果。然而，method 调用总会执行函数，计算属性是基于依赖缓存，计算属性只有在依赖发生改变时才会重新取值（计算属性的getter执行），也就是说，只要被依赖属性不变，多次访问计算属性可立即得到结果。
* `v-if` 作用于 `template` 上时，最终的渲染结果不会包括 `template`。
* `v-show` 是切换元素的 CSS 属性 `display`，所以 `v-show` 的元素始终渲染并保持在 DOM 中。
* `v-show` 不支持 `template` 语法。
* `v-if` 是真实的条件渲染,因为它会确保条件块在切换当中适当地销毁与重建条件块内的事件监听器和子组件。
* `v-if` 也是惰性的：如果在初始渲染时条件为假，则什么也不做---在条件第一次变为真时才开始局部变异（编译会被缓存起来）。
* `v-if` 有更高的切换消耗而 `v-show` 有更高的初始渲染消耗。因此，如果需要频繁切换使用 `v-show` 教好，如果在运行时条件不大可能发生改变时则使用 `v-if` 较好。
* `v-for` 优先级高于 `v-if`。
* `f-for` 遍历对象时，参数顺序 vaule、key、index，遍历数组时，参数顺序 item、index。